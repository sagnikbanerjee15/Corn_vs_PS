#! /usr/bin/env python3

from argparse import RawTextHelpFormatter
from pprint import pformat

import argparse
import logging
import os
import pprint
import sys
import re
import time
import multiprocessing
import random
import glob
import time
import subprocess


def parseCommandLineArguments():
    parser = argparse.ArgumentParser( prog = "annotate_fungal_genome", description = "Perform analysis to detect differentially expressed genes from raw RNA-Seq data", formatter_class = RawTextHelpFormatter )
    required_named = parser.add_argument_group( 'Required arguments' )
    optional_named = parser.add_argument_group( 'Optional arguments' )

    ##################################################################################################
    # Required arguments
    ##################################################################################################
    required_named.add_argument( "-metadatafilename", "--metadatafilename", help = "Enter the metadata file. The file format should be same as ListOfNCBI-SRASamplesForExperimentST.csv", required = True )
    required_named.add_argument( "-output_directory", "--output_directory", help = "Enter the name of the output directory. all analysis will be stored here. Please make sure you have sufficient space on your disk to reproduce all the analysis", required = True )
    required_named.add_argument( "-reference", "--reference", help = "Enter the name of the genome file in fasta format", required = True)
    required_named.add_argument( "--ps_reference", "--ps_reference", help = "Enter the name of the fungal reference genoem", required = True)

    ##################################################################################################
    # Optional arguments
    ##################################################################################################
    optional_named.add_argument( "--cpu", "-cpu", help = "Enter the number of CPUs. Please note that all alignments will be conducted using a single CPU. This argument will control how many parallel alignments can be launched", default = 1 )
    optional_named.add_argument( "--memory", "-memory", help = "Maxmimum memory limit", default = '100')
    optional_named.add_argument( "--temp_directory", "-temp_dir", help = "Enter a temporary directory. All files will be dumped in this directory to prevent the output directory to get crowded. Outputs and Error files will not be moved", default = None )
    optional_named.add_argument( "--transfer", "--transfer", help = "Keep moving intermediate files and folders from the output directory to the temp directory to reduce space consumption. Developed for Ceres architecture", action = "store_true")
    optional_named.add_argument( "--framework", "-fm", help = "Enter your choice of framework", choices = ["docker", "singularity"], default = "docker" )
    optional_named.add_argument( "--logfilename", "-logfilename", help = "Enter the name of the logfile" )
    
    ##################################################################################################
    # Suppressed arguments
    ##################################################################################################
    parser.add_argument( "--metadata_expanded", "-metadata_expanded", help = argparse.SUPPRESS )
    parser.add_argument( "--sra_list_to_be_downloaded", "-sra_list_to_be_downloaded", help = argparse.SUPPRESS )
    # Name of the logfile

    return parser.parse_args()


def configureLogger( options ):
    if os.path.exists( options.logfilename ) == True:
        os.system( f"rm -f {options.logfilename}" )
    logging.basicConfig( format = '%(asctime)s - %(message)s', datefmt = '%d-%b-%y %H:%M:%S', level = logging.DEBUG, filename = options.logfilename )


def runDockerCommand( logging, name, version, image_location, container_name, volumes, command , cpus = 1, memory = '1g' ):
    """
    Runs the command in a docker container
    """

    # Runs the main command
    docker_cmd = f" docker run "
    # docker_cmd += f" -ti "
    docker_cmd += f" --rm "
    docker_cmd += f" --cpus={cpus}"
    docker_cmd += f" --memory='{memory}'"
    # docker_cmd += f" --name {container_name}"
    for mapping in volumes:
        docker_cmd += f" -v {mapping}"
    docker_cmd += f" {image_location}:{version} "
    docker_cmd += f" bash -c '{command}'"
    logging.info( f"Running command - {docker_cmd}" )
    os.system( docker_cmd )

def runSingularityCommand( logging, name, version, image_location, container_name, volumes, command , cpus = 1, memory = '1g' ):
    """
    Runs the command in a Singularity container
    """

    # Runs the main command
    singularity_cmd = f" singularity exec  "
    # singularity_cmd += f" --hostname {container_name}"
    for mapping in volumes:
        singularity_cmd += f" -B {mapping}"
    singularity_cmd += f" {image_location} "
    singularity_cmd += f" bash -c \"{command}\" "
    os.system( singularity_cmd )
    #logging.info( f"Running command - {singularity_cmd}" )

def readMultiLineFastaFile(filename):
    
    fhr = open(filename,"r")
    sequences = {}
    while True:
        line = fhr.readline()
        if not line:break
        if line[0] == ">":
            sequence_id = line.strip()[1:]
            sequences[sequence_id] = ""
            continue
        sequences[sequence_id] += line.strip()
                
    sequences[sequence_id] += line.strip()
    fhr.close()
    return sequences

gencode = {
      'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
      'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
      'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
      'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
      'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
      'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
      'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
      'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
      'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
      'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
      'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
      'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
      'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
      'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
      'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
      'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W'}

basepairs = {'A':'T', 'C':'G', 'G':'C', 'T':'A'}

def translate_frameshifted( sequence ):
    translate = ''.join([gencode.get(sequence[3*i:3*i+3],'X') for i in range(len(sequence)//3)])
    return translate

def reverse_complement( sequence ):
    reversed_sequence = (sequence[::-1])
    rc = ''.join([basepairs.get(reversed_sequence[i], 'X') for i in range(len(sequence))])
    return rc

def lengthOfLongestORF(sequence):
    first_frame = translate_frameshifted(sequence[0:])
    second_frame = translate_frameshifted(sequence[1:])
    third_frame = translate_frameshifted(sequence[2:])
    
    rc_first_frame = translate_frameshifted(reverse_complement(sequence[0:]))
    rc_second_frame = translate_frameshifted(reverse_complement(sequence[1:]))
    rc_third_frame = translate_frameshifted(reverse_complement(sequence[2:]))
    
    translated_sequences = [first_frame,second_frame,third_frame,rc_first_frame,rc_second_frame,rc_third_frame]
    max_length_of_segments = []
    for translated_sequence in translated_sequences:
        length_of_translated_segments = [len(segment) for segment in translated_sequence.split("_")]
        max_length_of_segments.append(max(length_of_translated_segments))
        
    return max(max_length_of_segments)
    
def main():
    options = parseCommandLineArguments()
    
    os.system(f"mkdir -p {options.output_directory}")
    
    if options.logfilename == None:
        options.logfilename = f"{options.output_directory}/progress.log"
        
        
    configureLogger( options )    
    logging.info( "Logger has been configured" )
    
    ################################################################################################################################################################################################################################################
    # Pull down docker or singularity images
    ################################################################################################################################################################################################################################################
    
    access_key_raw = "ghp_fr6AvS8hayuREMOVETHISTEXTjmncOJqfLwgb0ueYXNk0hxnps"
    access_key = "".join(access_key_raw.split("REMOVETHISTEXT"))
    
    
    list_of_softwares_with_versions = {"samtools":"1.14",
                                       "trimmomatic":"0.39",
                                       "sratools":"3.0.0",
                                       "bowtie2":"0.7.17",
                                       "salmon":"1.8.0",
                                       "gffread":"0.12.1",
                                       "deseq2":"latest",
                                       "bowtie2":"2.4.5",
                                       "multiqc":"1.12",
                                       "star":"2.7.9a",
                                       "spades":"3.15.4",
                                       "cdhit":"4.8.1",
                                       "psiclass":"1.0.3",
                                       "stringtie":"2.2.1",
                                       "ncbi_blast":"2.13.0"}

    volumes_list = [f"{options.output_directory}:{options.output_directory}",
                    f"{options.temp_directory}:{options.temp_directory}",
                    f"{'/'.join(options.reference.split('/')[:-1])}:{'/'.join(options.reference.split('/')[:-1])}"
                    ]
    
    os.system( f"mkdir -p {options.output_directory}/singularity_images" )
    os.system( f"which docker > {options.output_directory}/find_docker 2> {options.output_directory}/find_docker" )
    os.system( f"which singularity > {options.output_directory}/find_singularity 2> {options.output_directory}/find_singularity" )
    docker_installed = 1 if "no docker in" not in open( f"{options.output_directory}/find_docker", "r" ).read() else 0
    singularity_installed = 1 if "no singularity in" not in open( f"{options.output_directory}/find_singularity", "r" ).read() else 0

    if docker_installed == 0 and singularity_installed == 0:
        print( "You need to have either docker or singularity installed" )
        sys.exit()

    framework_of_choice = ""
    if options.framework == "docker":
        if docker_installed == 1:
            framework_of_choice = "docker"
        else:
            framework_of_choice = "singularity"

    if options.framework == "singularity":
        if singularity_installed == 1:
            framework_of_choice = "singularity"
        else:
            framework_of_choice = "docker"
    
    if framework_of_choice == "docker":
        os.environ["CR_PAT"] = access_key
        os.system( f"echo $CR_PAT | docker login ghcr.io -u sagnikbanerjee15 --password-stdin" )
        for software in list_of_softwares_with_versions:
            version = list_of_softwares_with_versions[software]
            os.system( f"docker pull ghcr.io/sagnikbanerjee15/docker_tools_and_pipelines/{software}:{version}" )
    else:
        os.environ["CR_PAT"] = access_key
        os.system( f"echo $CR_PAT | singularity remote login -u sagnikbanerjee15 --password-stdin docker://ghcr.io" )
        for software in list_of_softwares_with_versions:
            version = list_of_softwares_with_versions[software]
            if os.path.exists(f"{options.output_directory}/singularity_images/{software}:{version}")==False:
                os.system( f"singularity pull {options.output_directory}/singularity_images/{software}:{version} docker://ghcr.io/sagnikbanerjee15/dockerized_tools_and_pipelines/{software}:{version}" )
    ################################################################################################################################################################################################################################################

    ################################################################################################################################################################################################################################################
    # Create directories and sub-directories for analysis
    ################################################################################################################################################################################################################################################
    options.main_directory_outputs_and_errors = f"{options.output_directory}/outputs_and_errors"
    options.temp_directory_outputs_and_errors = f"{options.temp_directory}/outputs_and_errors"
    os.system(f"mkdir -p {options.main_directory_outputs_and_errors}")
    os.system(f"mkdir -p {options.temp_directory_outputs_and_errors}")
    
    options.main_directory_raw_reads = f"{options.output_directory}/raw_reads"
    options.temp_directory_raw_reads = f"{options.temp_directory}/raw_reads"
    os.system(f"mkdir -p {options.main_directory_raw_reads}")
    os.system(f"mkdir -p {options.temp_directory_raw_reads}")
    
    options.main_directory_star_index = f"{options.output_directory}/star_index"
    options.temp_directory_star_index = f"{options.temp_directory}/star_index"
    os.system(f"mkdir -p {options.main_directory_star_index}")
    os.system(f"mkdir -p {options.temp_directory_star_index}")
    
    options.main_directory_trimmed_reads = f"{options.output_directory}/trimmed_reads"
    options.temp_directory_trimmed_reads = f"{options.temp_directory}/trimmed_reads"
    os.system(f"mkdir -p {options.main_directory_trimmed_reads}")
    os.system(f"mkdir -p {options.temp_directory_trimmed_reads}")
    
    options.main_directory_alignments_to_combined_reference = f"{options.output_directory}/alignments_combined_reference"
    options.temp_directory_alignments_to_combined_reference = f"{options.temp_directory}/alignments_combined_reference"
    os.system(f"mkdir -p {options.main_directory_alignments_to_combined_reference}")
    os.system(f"mkdir -p {options.temp_directory_alignments_to_combined_reference}")
    
    options.main_directory_alignments_to_fungal_reference = f"{options.output_directory}/alignments_fungal_reference"
    options.temp_directory_alignments_to_fungal_reference = f"{options.temp_directory}/alignments_fungal_reference"
    os.system(f"mkdir -p {options.main_directory_alignments_to_fungal_reference}")
    os.system(f"mkdir -p {options.temp_directory_alignments_to_fungal_reference}")
    
    options.main_directory_spades_denovo_assembly = f"{options.output_directory}/spades_denovo_assembly"
    options.temp_directory_spades_denovo_assembly = f"{options.temp_directory}/spades_denovo_assembly"
    os.system(f"mkdir -p {options.main_directory_spades_denovo_assembly}")
    os.system(f"mkdir -p {options.temp_directory_spades_denovo_assembly}")
    
    options.main_directory_psiclass_assembly_replicates_merged = f"{options.output_directory}/psiclass_assembly_replicates_merged"
    options.temp_directory_psiclass_assembly_replicates_merged = f"{options.temp_directory}/psiclass_assembly_replicates_merged"
    os.system(f"mkdir -p {options.main_directory_psiclass_assembly_replicates_merged}")
    os.system(f"mkdir -p {options.main_directory_psiclass_assembly_replicates_merged}")
    
    options.main_directory_psiclass_assembly_replicates_separate = f"{options.output_directory}/psiclass_assembly_replicates_separate"
    options.temp_directory_psiclass_assembly_replicates_separate = f"{options.temp_directory}/psiclass_assembly_replicates_separate"
    os.system(f"mkdir -p {options.main_directory_psiclass_assembly_replicates_separate}")
    os.system(f"mkdir -p {options.temp_directory_psiclass_assembly_replicates_separate}")
    
    options.main_directory_stringtie_assembly = f"{options.output_directory}/stringtie_assembly"
    options.temp_directory_stringtie_assembly = f"{options.output_directory}/stringtie_assembly"
    os.system(f"mkdir -p {options.main_directory_stringtie_assembly}")
    os.system(f"mkdir -p {options.temp_directory_stringtie_assembly}")

    logging.info("Directories have been created")
    ################################################################################################################################################################################################################################################
    # Read data from metadata file
    ################################################################################################################################################################################################################################################
    
    # Restruture later
    fhr = open(options.metadatafilename, "r")
    options.metadata = []
    for line in fhr:
        if "SampleName" in line: continue
        options.metadata.append(line.strip().split(','))
    fhr.close()
    
    
    ################################################################################################################################################################################################################################################
    # Prepare genome indices
    ################################################################################################################################################################################################################################################ 
    # Generate the STAR index
    if os.path.exists(f"{options.main_directory_star_index}/genomeParameters.txt") == False and os.path.exists(f"{options.temp_directory_star_index}/genomeParameters.txt") == False:
        cmd = f"STAR --runMode genomeGenerate --runThreadN {options.cpu} --genomeFastaFiles {options.reference} --genomeDir {options.main_directory_star_index}"
        cmd += f" 1> {options.main_directory_outputs_and_errors}/STAR_index_creation_combined_genome.output"
        cmd += f" 2> {options.main_directory_outputs_and_errors}/STAR_index_creation_combined_genome.error"
        
        software = "star"
        version = list_of_softwares_with_versions[software]
        runSingularityCommand(logging, 
                              "STAR", 
                              version, 
                              image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                              container_name = "star_index_prep", 
                              volumes = volumes_list,
                              command = cmd, 
                              cpus = options.cpu, 
                              memory = f'{options.memory}g')
        logging.info("STAR index generation completed")
        
        # Move the star index to the temp directory if a transfer is requested
        if (options.transfer):
            cmd = f"mv {options.main_directory_star_index} {options.temp_directory_star_index}/.."
            os.system(cmd)
            logging.info("STAR index has been transferred to temporary directory")
            
            cmd = f"rm -rf {options.main_directory_star_index}"
            os.system(cmd)
    else:
        logging.info("STAR index exists, skipping regeneration")


    # Copy the reference index if it is not present
    if os.path.exists(f"{options.main_directory_star_index}") == False:
        cmd = f"cp -r {options.temp_directory_star_index} {options.main_directory_star_index}/.."
        os.system(cmd)
    ################################################################################################################################################################################################################################################
    
    # Read in the sequence ids in the fungal reference
    fungal_references = []
    fhr = open(options.ps_reference, "r")
    for line in fhr:
        if line[0] == ">":
            fungal_references.append(line.strip()[1:])
    fhr.close()
    fungal_references = set(fungal_references)
    
    ################################################################################################################################################################################################################################################
    # Trim reads and align to combined reference
    ################################################################################################################################################################################################################################################
    for row in options.metadata:
        samplename, ended, cultivar, condition, timepoint, biological_replicate, location = row
        
        ################################################################################################################################################################################################################################################
        # Perform adapter trimming using trimmomatic
        ################################################################################################################################################################################################################################################
        
        if os.path.exists(f"{options.main_directory_trimmed_reads}/{samplename}_1.fastq.gz") == False or os.path.exists(f"{options.temp_directory_trimmed_reads}/{samplename}_1.fastq.gz") == False or os.path.exists(f"{options.main_directory_trimmed_reads}/{samplename}_2.fastq.gz") == False or os.path.exists(f"{options.temp_directory_trimmed_reads}/{samplename}_2.fastq.gz") == False:
            # Copy the raw data from the directory
            if ended == "SE":
                cmd = f"cp {location}/{samplename}.fastq.gz {options.main_directory_raw_reads}"
                os.system(cmd)
            else:
                if os.path.exists(f"{options.main_directory_raw_reads}/{samplename}_1.fastq.gz") == False:
                    cmd = f"cp {location}/{samplename}_1.fastq.gz {options.main_directory_raw_reads}"
                    os.system(cmd)
                if os.path.exists(f"{options.main_directory_raw_reads}/{samplename}_2.fastq.gz") == False:
                    cmd = f"cp {location}/{samplename}_2.fastq.gz {options.main_directory_raw_reads}"
                    os.system(cmd)
            logging.info(f"Raw files copied to main directory for {samplename}")
        
            cmd  = f"trimmomatic "
            cmd += f" PE "
            cmd += f" -threads {options.cpu}"
            cmd += f" -summary {options.main_directory_outputs_and_errors}/{samplename}_trimmomatic.summary "
            cmd += f" {options.main_directory_raw_reads}/{samplename}_1.fastq.gz {options.main_directory_raw_reads}/{samplename}_2.fastq.gz " 
            cmd += f" {options.main_directory_trimmed_reads}/{samplename}_1.fastq.gz {options.main_directory_trimmed_reads}/{samplename}_1_unpaired.fastq.gz "
            cmd += f" {options.main_directory_trimmed_reads}/{samplename}_2.fastq.gz {options.main_directory_trimmed_reads}/{samplename}_2_unpaired.fastq.gz "
            cmd += f" ILLUMINACLIP:/opt/conda/share/trimmomatic-0.39-2/adapters/TruSeq3-PE-2.fa:2:30:10 "
            cmd += f" MINLEN:100 "
            cmd += f" 1> {options.main_directory_outputs_and_errors}/{samplename}_trimmomatic_adapter_removal.output"
            cmd += f" 2> {options.main_directory_outputs_and_errors}/{samplename}_trimmomatic_adapter_removal.error"
            
            software = "trimmomatic"
            version = list_of_softwares_with_versions[software]
            runSingularityCommand(logging, 
                                  "Trimmomatic", 
                                  version, 
                                  image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                                  container_name = f"trimmomatic_adapter_removal_{samplename}",
                                  volumes = volumes_list,
                                  command = cmd, 
                                  cpus = options.cpu, 
                                  memory = f'{options.memory}g')
            logging.info(f"Adpater removal with Trimmomatic completed for {samplename}")
            
            cmd = f"rm {options.main_directory_trimmed_reads}/{samplename}*unpaired* "
            os.system(cmd)
            
            if options.transfer:
                cmd = f"cp {options.main_directory_trimmed_reads}/{samplename}_*.fastq.gz {options.temp_directory_trimmed_reads}"
                os.system(cmd)
                logging.info(f"Transfer complete for trimmed reads of {samplename} to temp directory")
        else:
            logging.info(f"Skipping Trimmomatic run for {samplename}")
        
        ################################################################################################################################################################################################################################################
        # Align short reads to reference
        ################################################################################################################################################################################################################################################
        if os.path.exists(f"{options.output_directory}/alignments/{samplename}_Aligned.sortedByCoord.out.bam") == False and os.path.exists(f"{options.temp_directory}/alignments/{samplename}_Aligned.sortedByCoord.out.bam") == False:
            if os.path.exists(f"{options.main_directory_trimmed_reads}/{samplename}_1.fastq.gz") == False or os.path.exists(f"{options.main_directory_trimmed_reads}/{samplename}_2.fastq.gz") == False:
                # Copy the raw data from the directory
                if ended == "SE":
                    cmd = f"cp {options.temp_directory_trimmed_reads}/{samplename}.fastq.gz {options.main_directory_trimmed_reads}"
                    os.system(cmd)
                else:
                    cmd = f"cp {options.temp_directory_trimmed_reads}/{samplename}_1.fastq.gz {options.main_directory_trimmed_reads}"
                    os.system(cmd)
                    cmd = f"cp {options.temp_directory_trimmed_reads}/{samplename}_2.fastq.gz {options.main_directory_trimmed_reads}"
                    os.system(cmd)            
            cmd  = f"STAR "
            cmd += f" --runThreadN {options.cpu} "
            cmd += f" --outBAMsortingThreadN {options.cpu}"
            cmd += f" --genomeDir {options.main_directory_star_index}"
            cmd += f" --outSAMtype BAM SortedByCoordinate "
            cmd += f" --outFilterMultimapNmax 100 "  
            cmd += f" --alignIntronMin 20  "
            cmd += f" --alignIntronMax 10000 "
            cmd += f" --limitBAMsortRAM 107374182400 "
            cmd += f" --alignEndsType Local " # ALLOWS soft clipping 
            cmd += f" --outSAMprimaryFlag AllBestScore "
            cmd += f" --outFilterScoreMinOverLread 0.7"
            cmd += f" --outFilterMatchNminOverLread 0.7 "
            cmd += f" --outSAMattributes NH HI AS nM NM MD jM jI XS "
            cmd += f" --outReadsUnmapped Fastx "
            cmd += f" --outFileNamePrefix {options.main_directory_alignments_to_combined_reference}/{samplename}_"
            cmd += f" --readFilesCommand zcat "
            cmd += f" --readFilesIn {options.main_directory_trimmed_reads}/{samplename}_1.fastq.gz {options.main_directory_trimmed_reads}/{samplename}_2.fastq.gz "
            cmd += f" 1> {options.main_directory_outputs_and_errors}/{samplename}_STAR_alignment_to_combined_reference.output "
            cmd += f" 2> {options.main_directory_outputs_and_errors}/{samplename}_STAR_alignment_to_combined_reference.error "
            
            software = "star"
            version = list_of_softwares_with_versions[software]
            runSingularityCommand(logging, 
                                  "STAR", 
                                  version, 
                                  image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                                  container_name = f"star_alignment_{samplename}",
                                  volumes = volumes_list,
                                  command = cmd, 
                                  cpus = options.cpu, 
                                  memory = f'{options.memory}g')
            logging.info(f"STAR alignment completed for sample no {samplename}")
            
            ################################################################################################################################################################################################################################################
            # Extract alignments to the fungal references
            ################################################################################################################################################################################################################################################ 
            
            bamfilename = f"{options.main_directory_alignments_to_combined_reference}/{samplename}_Aligned.sortedByCoord.out.bam"
            samfilename = f"{options.main_directory_alignments_to_combined_reference}/{samplename}_Aligned.sortedByCoord.out.sam"
            samfilename_only_fungal_alignments = f"{options.main_directory_alignments_to_fungal_reference}/{samplename}_Aligned.sortedByCoord.out.sam"
            bamfilename_only_fungal_alignments = f"{options.main_directory_alignments_to_fungal_reference}/{samplename}_Aligned.sortedByCoord.out.bam"
            
            if os.path.exists(f"{options.temp_directory_alignments_to_fungal_reference}/{samplename}_Aligned.sortedByCoord.out.bam") == False and os.path.exists(bamfilename_only_fungal_alignments) == False:
        
                if os.path.exists(f"{options.temp_directory_alignments_to_combined_reference}/{samplename}_Aligned.sortedByCoord.out.bam") == True and os.path.exists(f"{options.main_directory_alignments_to_combined_reference}/{samplename}_Aligned.sortedByCoord.out.bam") == False:
                    cmd = f"cp {options.temp_directory_alignments_to_combined_reference}/{samplename}_Aligned.sortedByCoord.out.bam {options.main_directory_alignments_to_combined_reference}/"
                    os.system(cmd)
                
                # Convert the bamfile to samfile
                cmd = f"samtools view -@ {options.cpu} -h {bamfilename} > {samfilename}"
                software = "samtools"
                version = list_of_softwares_with_versions[software]
                runSingularityCommand(logging, 
                                      "samtools", 
                                      version, 
                                      image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                                      container_name = "samtools_convert_bam_to_sam", 
                                      volumes = volumes_list,
                                      command = cmd, 
                                      cpus = options.cpu, 
                                      memory = f'{options.memory}g')
                
                # Extract the alignments to the fungal reference
                fhr = open(samfilename, "r")
                fhw = open(samfilename_only_fungal_alignments, "w")
                for line in fhr:
                    if line[0] == "@":
                        if "@HD" in line:
                            fhw.write(line)
                        elif line.strip().split("SN:")[-1].split()[0] in fungal_references:
                            fhw.write(line)
                    else:
                        if line.strip().split()[2] in fungal_references:
                            fhw.write(line)
                fhw.close()
                fhr.close()
                
                # Convert the extracted samfile to bamfile
                cmd = f"samtools view -@ {options.cpu} -bS {samfilename_only_fungal_alignments} > {bamfilename_only_fungal_alignments}"
                software = "samtools"
                version = list_of_softwares_with_versions[software]
                runSingularityCommand(logging, 
                                      "samtools", 
                                      version, 
                                      image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                                      container_name = "samtools_convert_sam_to_bam", 
                                      volumes = volumes_list,
                                      command = cmd, 
                                      cpus = options.cpu, 
                                      memory = f'{options.memory}g')
                logging.info(f"Fungal reads extracted from sample {samplename}")
            
            if options.transfer:
                cmd = f"mv {options.main_directory_alignments_to_combined_reference}/{samplename}*.bam {options.temp_directory_alignments_to_combined_reference}"
                os.system(cmd)
                
                cmd = f"mv {options.main_directory_alignments_to_combined_reference}/{samplename}*.out {options.temp_directory_alignments_to_combined_reference}"
                os.system(cmd)
                
                cmd = f"mv {options.main_directory_alignments_to_combined_reference}/{samplename}*.out.mate* {options.temp_directory_alignments_to_combined_reference}"
                os.system(cmd)
                
                cmd = f"mv {bamfilename_only_fungal_alignments} {options.temp_directory_alignments_to_fungal_reference}"
                os.system(cmd)
                
                cmd = f"rm {options.main_directory_trimmed_reads}/{samplename}*gz"
                os.system(cmd)
                
                cmd = f"rm {options.main_directory_raw_reads}/{samplename}*gz"
                os.system(cmd)
                
                cmd = f"rm {options.main_directory_alignments_to_combined_reference}/{samplename}_Aligned.sortedByCoord.out.*am"
                os.system(cmd)
                
                cmd = f"rm {samfilename_only_fungal_alignments}"
                os.system(cmd)
        else:
            logging.info(f"STAR mapping has been generated for sample {samplename}")
    
    
    ################################################################################################################################################################################################################################################
    
    ################################################################################################################################################################################################################################################
    # Combine all unmapped reads
    ################################################################################################################################################################################################################################################
    if os.path.exists(f"{options.main_directory_spades_denovo_assembly}/all_unmapped_reads_1.fastq") == False or os.path.exists(f"{options.main_directory_spades_denovo_assembly}/all_unmapped_reads_2.fastq") == False or os.path.exists(f"{options.temp_directory_spades_denovo_assembly}/all_unmapped_reads_1.fastq") == False or os.path.exists(f"{options.temp_directory_spades_denovo_assembly}/all_unmapped_reads_2.fastq") == False: 
        cmd_1 = f"cat "
        cmd_2 = f"cat "
        for row in options.metadata:
            samplename, ended, cultivar, condition, timepoint, biological_replicate, location = row
            cmd_1 += f" {options.temp_directory_alignments_to_combined_reference}/{samplename}_Unmapped.out.mate1|gzip -c  "
            cmd_2 += f" {options.temp_directory_alignments_to_combined_reference}/{samplename}_Unmapped.out.mate2|gzip -c "
        cmd_1 += f" > {options.main_directory_spades_denovo_assembly}/all_unmapped_reads_1.fastq.gz "
        cmd_2 += f" > {options.main_directory_spades_denovo_assembly}/all_unmapped_reads_2.fastq.gz "
        os.system(cmd_1)
        os.system(cmd_2)
        logging.info(f"Merging all unmapped reads from samples")
        
        if options.transfer:
            cmd = f"cp {options.main_directory_spades_denovo_assembly}/all_unmapped_reads_*.fastq.gz {options.temp_directory_spades_denovo_assembly}"
            os.system(cmd)
            logging.info(f"All unmapped merged reads copied to temp directory")
            
            cmd = f"rm {options.main_directory_spades_denovo_assembly}/all_unmapped_reads_*.fastq.gz "
            os.system(cmd)
    ################################################################################################################################################################################################################################################
    
      
    ################################################################################################################################################################################################################################################
    # Generate fungal genome assembly genome guided
    ################################################################################################################################################################################################################################################
    
    ################################################################################################################################################################################################################################################
    # PsiCLASS
    ################################################################################################################################################################################################################################################
    
    # Copy all fungal bam files to output directory
    for row in options.metadata:
        samplename, ended, cultivar, condition, timepoint, biological_replicate, location = row
        if os.path.exists(f"{options.main_directory_alignments_to_fungal_reference}/{samplename}_Aligned.sortedByCoord.out.bam") == False:
            cmd = f"cp {options.temp_directory_alignments_to_fungal_reference}/{samplename}_Aligned.sortedByCoord.out.bam {options.main_directory_alignments_to_fungal_reference}"
            os.system(cmd)
            
    # Merge all fungal bam files into one
    cmd  = f"samtools merge "
    cmd += f" -@ {options.cpu} "
    cmd += f" -o {options.main_directory_stringtie_assembly}/all_samples_merged.bam "
    for row in options.metadata:
        samplename, ended, cultivar, condition, timepoint, biological_replicate, location = row
        cmd += f" {options.main_directory_alignments_to_fungal_reference}/{samplename}_Aligned.sortedByCoord.out.bam "
    if os.path.exists(f"{options.main_directory_stringtie_assembly}/all_samples_merged.bam") == False:
        software = "samtools"
        version = list_of_softwares_with_versions[software]
        runSingularityCommand(logging, 
                          "samtools_merge", 
                          version, 
                          image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                          container_name = "samtools_merge", 
                          volumes = volumes_list,
                          command = cmd, 
                          cpus = options.cpu, 
                          memory = f'{options.memory}g')
        if options.transfer:
            cmd = f"cp {options.main_directory_stringtie_assembly}/all_samples_merged.bam {options.temp_directory_stringtie_assembly}"
            os.system(cmd)
    
    # Compile a list of bam files
    fhw = open(f"{options.main_directory_alignments_to_fungal_reference}/list_of_bam_files_replicates_separate","w")
    for row in options.metadata:
        samplename, ended, cultivar, condition, timepoint, biological_replicate, location = row
        fhw.write(f"{options.main_directory_alignments_to_fungal_reference}/{samplename}_Aligned.sortedByCoord.out.bam"+"\n")
    fhw.close()
    
    # Replicates not merged
    cmd  = f" psiclass "
    cmd += f" --lb {options.main_directory_alignments_to_fungal_reference}/list_of_bam_files_replicates_separate "
    cmd += f" -o {options.psiclass_assembly_replicates_separate}/psiclass_output"
    cmd += f" -p {options.cpu}"
    cmd += f" --primaryParalog "
    cmd += f" 1> {options.main_directory_spades_denovo_assembly}/psiclass_assembly_replicates_separate.output "
    cmd += f" 2> {options.main_directory_spades_denovo_assembly}/psiclass_assembly_replicates_separate.error "
    software = "psiclass"
    version = list_of_softwares_with_versions[software]
    
    if os.path.exists(f"{options.psiclass_assembly_replicates_separate}/psiclass_output_vote.gtf") == False:
        runSingularityCommand(logging, 
                              "psiclass_replicates_separate", 
                              version, 
                              image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                              container_name = "gg_assembly_psiclass", 
                              volumes = volumes_list,
                              command = cmd, 
                              cpus = options.cpu, 
                              memory = f'{options.memory}g')
    
    # Merge replicates
    replicates_group = {}
    for row in options.metadata:
        samplename, ended, cultivar, condition, timepoint, biological_replicate, location = row
        if f"{cultivar}~{condition}~{timepoint}" not in replicates_group:
            replicates_group[f"{cultivar}~{condition}~{timepoint}"] = []
        replicates_group[f"{cultivar}~{condition}~{timepoint}"].append(samplename)
        
    fhw = open(f"{options.main_directory_alignments_to_fungal_reference}/list_of_bam_files_replicates_merged","w")
    for category in replicates_group:
        merged_bamfilename = f"{options.main_directory_alignments_to_fungal_reference}/{category}.bam"
        fhw.write(merged_bamfilename + "\n")
        
        cmd  = f" samtools merge "
        cmd += f" -@ {options.cpu} "
        cmd += f" {merged_bamfilename} "
        for samplename in replicates_group[category]:
            cmd += f" {options.main_directory_alignments_to_fungal_reference}/{samplename}_Aligned.sortedByCoord.out.bam "
        
        software = "samtools"
        version = list_of_softwares_with_versions[software]
        runSingularityCommand(logging, 
                              "samtools", 
                              version, 
                              image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                              container_name = "samtools_merge", 
                              volumes = volumes_list,
                              command = cmd, 
                              cpus = options.cpu, 
                              memory = f'{options.memory}g')
    fhw.close()
    
    # Replicates merged
    cmd  = f" psiclass "
    cmd += f" --lb {options.main_directory_alignments_to_fungal_reference}/list_of_bam_files_replicates_merged "
    cmd += f" -o {options.psiclass_assembly_replicates_merged}/psiclass_output"
    cmd += f" -p {options.cpu}"
    cmd += f" --primaryParalog "
    cmd += f" 1> {options.main_directory_spades_denovo_assembly}/psiclass_assembly_replicates_merged.output "
    cmd += f" 2> {options.main_directory_spades_denovo_assembly}/psiclass_assembly_replicates_merged.error "
    
    software = "psiclass"
    version = list_of_softwares_with_versions[software]
    if os.path.exists(f"{options.psiclass_assembly_replicates_merged}/psiclass_output_vote.gtf") == False:
        runSingularityCommand(logging, 
                          "psiclass_replicates_merged", 
                          version, 
                          image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                          container_name = "gg_assembly_psiclass", 
                          volumes = volumes_list,
                          command = cmd, 
                          cpus = options.cpu, 
                          memory = f'{options.memory}g')
    
     
    
    ################################################################################################################################################################################################################################################
    # Stringtie
    ################################################################################################################################################################################################################################################
    
    # Merge all the fungal alignments
    
    if os.path.exists(f"{options.main_directory_stringtie_assembly}/all_samples_merged.gtf") == False or os.path.exists(f"{options.temp_directory_stringtie_assembly}/all_samples_merged.gtf") == False:
        cmd  = "stringtie"
        cmd += f" -o {options.main_directory_stringtie_assembly}/all_samples_merged.gtf "
        cmd += f" -p {options.cpu} "
        cmd += f" -m 300 "
        cmd += f" {options.main_directory_stringtie_assembly}/all_samples_merged.bam "
    
        software = "stringtie"
        version = list_of_softwares_with_versions[software]
        
        runSingularityCommand(logging, 
                          "stringtie_assembly", 
                          version, 
                          image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                          container_name = "gg_assembly_stringtie", 
                          volumes = volumes_list,
                          command = cmd, 
                          cpus = options.cpu, 
                          memory = f'{options.memory}g')
        
        if options.transfer:
            cmd = f"mv {options.main_directory_stringtie_assembly}/all_samples_merged.gtf {options.temp_directory_stringtie_assembly}/all_samples_merged.gtf"
            os.system(cmd)
    
    return
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    ################################################################################################################################################################################################################################################    
    # De novo assemble the unmapped reads
    ################################################################################################################################################################################################################################################
    if os.path.exists(f"{options.main_directory_spades_denovo_assembly}/merged_assembly/transcripts.fasta") == False and os.path.exists(f"{options.temp_directory_spades_denovo_assembly}/merged_assembly/transcripts.fasta") == False:
        # Copy the input data for performing de novo assembly
        if os.path.exists(f"{options.main_directory_spades_denovo_assembly}/all_unmapped_reads_1.fastq") == False or os.path.exists(f"{options.main_directory_spades_denovo_assembly}/all_unmapped_reads_2.fastq") == False:
            cmd = f"cp {options.temp_directory_spades_denovo_assembly}/all_unmapped_reads_*fastq {options.main_directory_spades_denovo_assembly}"
            os.system(cmd)
            logging.info(f"Merged unmapped files copied from temp directory")
            
        cmd  = f"spades.py "
        cmd += f" --rna "
        cmd += f" -1 {options.main_directory_spades_denovo_assembly}/all_unmapped_reads_1.fastq.gz "
        cmd += f" -2 {options.main_directory_spades_denovo_assembly}/all_unmapped_reads_2.fastq.gz "
        cmd += f" --threads 20"
        cmd += f" -k 101 "
        cmd += f" -o {options.main_directory_spades_denovo_assembly}/merged_assembly "
        cmd += f" 1> {options.main_directory_outputs_and_errors}/spades_assembly.output "
        cmd += f" 2> {options.main_directory_outputs_and_errors}/spades_assembly.error "
        logging.info(f"De novo assembly generation completed")
        
        software = "spades"
        version = list_of_softwares_with_versions[software]
        runSingularityCommand(logging, 
                                  "spades", 
                                  version, 
                                  image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                                  container_name = "spades_assembly",
                                  volumes = volumes_list,
                                  command = cmd, 
                                  cpus = options.cpu, 
                                  memory = '1500g')
        
        if options.transfer:
            cmd = f"mv {options.main_directory_spades_denovo_assembly}/merged_assembly {options.temp_directory_spades_denovo_assembly}"
            os.system(cmd)
    else:
        logging.info(f"Skipping generation of de novo assembly")
    

    ################################################################################################################################################################################################################################################
    # Generate a single transcriptome from unmapped reads
    ################################################################################################################################################################################################################################################
    
    merged_filename = f"{options.denovo_assembly}/merged_transcripts.fasta"
    if os.path.exists(merged_filename) == False:
        all_sequences = {}
        for row in options.metadata:
            samplename, ended, cultivar, condition, timepoint, biological_replicate, location = row
            ################################################################################################################################################################################################################################################
            # Copy assembled "transcripts" to working folder
            ################################################################################################################################################################################################################################################
            cmd = f"mkdir -p {options.denovo_assembly}/{samplename}_101"
            os.system(cmd)
            cmd = f"cp {options.temp_directory}/denovo_assembly/{samplename}_101/transcripts.fasta {options.denovo_assembly}/{samplename}_101/"
            os.system(cmd)
            
            denovo_assembled_sequences = readMultiLineFastaFile(f"{options.denovo_assembly}/{samplename}_101/transcripts.fasta")
            
            # Remove sequences that have less than 100 aa
            sequence_ids_to_be_removed = []
            for sequence_id in denovo_assembled_sequences: 
                if lengthOfLongestORF(denovo_assembled_sequences[sequence_id]) < 100:
                    sequence_ids_to_be_removed.append(sequence_id)
            
            for sequence_id in sequence_ids_to_be_removed:
                del denovo_assembled_sequences[sequence_id]
                
            for sequence_id in denovo_assembled_sequences:
                all_sequences[f"{sequence_id}_{cultivar}_{condition}_{timepoint}_{biological_replicate}"] = denovo_assembled_sequences[sequence_id]
                
        
        fhw = open(merged_filename,"w")
        for sequence_id in all_sequences:
            fhw.write(f">{sequence_id}\n{all_sequences[sequence_id]}\n")
        fhw.close()
    logging.info("All de novo assemblies are merged")
    
    # Generate CDHIT clusters
    for cluster_similarity in [0.8, 0.85, 0.9, 0.95]:
        cmd  = f"cd-hit-est "
        cmd += f" -i {options.denovo_assembly}/merged_transcripts.fasta "
        cmd += f" -o {options.denovo_assembly}/merged_transcripts_cdhit_clusters_{cluster_similarity} "
        cmd += f" -c {cluster_similarity} "
        cmd += f" -T {options.cpu} "
        cmd += f" -d 0 "
        cmd += f" -M 10000 "
        cmd += f" 1> {options.denovo_assembly}/merged_transcripts_cdhit_clusters_{cluster_similarity}.output "
        cmd += f" 2> {options.denovo_assembly}/merged_transcripts_cdhit_clusters_{cluster_similarity}.error "
        
        if os.path.exists(f"{options.denovo_assembly}/merged_transcripts_cdhit_clusters_{cluster_similarity}.clstr") == False:
            software = "cdhit"
            version = list_of_softwares_with_versions[software]
            runSingularityCommand(logging, 
                                  "CDHIT", 
                                  version, 
                                  image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                                  container_name = "star_alignment",
                                  volumes = volumes_list,
                                  command = cmd, 
                                  cpus = options.cpu, 
                                  memory = f'{options.memory}g')
            logging.info(f"CDHIT execution completed for cluster threshold {cluster_similarity}")  
    logging.info("CDHIT execution complete")
    
    
    ################################################################################################################################################################################################################################################
    # Copy all output and errors to the temp directory
    ################################################################################################################################################################################################################################################
    if options.transfer:
        cmd = f"cp -r {options.main_directory_outputs_and_errors} {options.temp_directory_outputs_and_errors}/.."
        os.system(cmd)
    
    
if __name__ == "__main__":
    main()
    
    
    
    
    