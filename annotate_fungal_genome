#! /usr/bin/env python3

from argparse import RawTextHelpFormatter
from pprint import pformat

import argparse
import logging
import os
import pprint
import sys
import re
import time
import multiprocessing
import random
import glob
import time
import subprocess


def parseCommandLineArguments():
    parser = argparse.ArgumentParser( prog = "annotate_fungal_genome", description = "Perform analysis to detect differentially expressed genes from raw RNA-Seq data", formatter_class = RawTextHelpFormatter )
    required_named = parser.add_argument_group( 'Required arguments' )
    optional_named = parser.add_argument_group( 'Optional arguments' )

    ##################################################################################################
    # Required arguments
    ##################################################################################################
    required_named.add_argument( "-metadatafilename", "--metadatafilename", help = "Enter the metadata file. The file format should be same as ListOfNCBI-SRASamplesForExperimentST.csv", required = True )
    required_named.add_argument( "-output_directory", "--output_directory", help = "Enter the name of the output directory. all analysis will be stored here. Please make sure you have sufficient space on your disk to reproduce all the analysis", required = True )
    required_named.add_argument( "-reference", "--reference", help = "Enter the name of the genome file in fasta format", required = True)

    ##################################################################################################
    # Optional arguments
    ##################################################################################################
    optional_named.add_argument( "--cpu", "-cpu", help = "Enter the number of CPUs. Please note that all alignments will be conducted using a single CPU. This argument will control how many parallel alignments can be launched", default = 1 )
    optional_named.add_argument( "--temp_directory", "-temp_dir", help = "Enter a temporary directory. All files will be dumped in this directory to prevent the output directory to get crowded. Outputs and Error files will not be moved", default = None )
    optional_named.add_argument( "--transfer", "--transfer", help = "Keep moving intermediate files and folders from the output directory to the temp directory to reduce space consumption. Developed for Ceres architecture", action = "store_true")
    optional_named.add_argument( "--framework", "-fm", help = "Enter your choice of framework", choices = ["docker", "singularity"], default = "docker" )
    optional_named.add_argument( "--logfilename", "-logfilename", help = "Enter the name of the logfile" )

    ##################################################################################################
    # Suppressed arguments
    ##################################################################################################
    parser.add_argument( "--metadata_expanded", "-metadata_expanded", help = argparse.SUPPRESS )
    parser.add_argument( "--sra_list_to_be_downloaded", "-sra_list_to_be_downloaded", help = argparse.SUPPRESS )
    # Name of the logfile

    return parser.parse_args()


def configureLogger( options ):
    if os.path.exists( options.logfilename ) == True:
        os.system( f"rm -f {options.logfilename}" )
    logging.basicConfig( format = '%(asctime)s - %(message)s', datefmt = '%d-%b-%y %H:%M:%S', level = logging.DEBUG, filename = options.logfilename )


def runDockerCommand( logging, name, version, image_location, container_name, volumes, command , cpus = 1, memory = '1g' ):
    """
    Runs the command in a docker container
    """

    # Runs the main command
    docker_cmd = f" docker run "
    # docker_cmd += f" -ti "
    docker_cmd += f" --rm "
    docker_cmd += f" --cpus={cpus}"
    docker_cmd += f" --memory='{memory}'"
    # docker_cmd += f" --name {container_name}"
    for mapping in volumes:
        docker_cmd += f" -v {mapping}"
    docker_cmd += f" {image_location}:{version} "
    docker_cmd += f" bash -c '{command}'"
    logging.info( f"Running command - {docker_cmd}" )
    os.system( docker_cmd )

def runSingularityCommand( logging, name, version, image_location, container_name, volumes, command , cpus = 1, memory = '1g' ):
    """
    Runs the command in a Singularity container
    """

    # Runs the main command
    singularity_cmd = f" singularity exec  "
    # singularity_cmd += f" --hostname {container_name}"
    for mapping in volumes:
        singularity_cmd += f" -B {mapping}"
    singularity_cmd += f" {image_location} "
    singularity_cmd += f" bash -c \"{command}\" "
    os.system( singularity_cmd )
    logging.info( f"Running command - {singularity_cmd}" )

def readMultiLineFastaFile(filename):
    
    fhr = open(filename,"r")
    sequences = {}
    while True:
        line = fhr.readline()
        if not line:break
        if line[0] == ">":
            sequence_id = line.strip()[1:]
            sequences[sequence_id] = ""
            continue
        sequences[sequence_id] += line.strip()
                
    sequences[sequence_id] += line.strip()
    fhr.close()
    return sequences

gencode = {
      'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
      'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
      'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
      'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
      'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L',
      'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
      'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
      'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
      'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
      'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
      'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
      'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
      'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
      'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
      'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
      'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W'}

basepairs = {'A':'T', 'C':'G', 'G':'C', 'T':'A'}

def translate_frameshifted( sequence ):
    translate = ''.join([gencode.get(sequence[3*i:3*i+3],'X') for i in range(len(sequence)//3)])
    return translate

def reverse_complement( sequence ):
    reversed_sequence = (sequence[::-1])
    rc = ''.join([basepairs.get(reversed_sequence[i], 'X') for i in range(len(sequence))])
    return rc

def lengthOfLongestORF(sequence):
    first_frame = translate_frameshifted(sequence[0:])
    second_frame = translate_frameshifted(sequence[1:])
    third_frame = translate_frameshifted(sequence[2:])
    
    rc_first_frame = translate_frameshifted(reverse_complement(sequence[0:]))
    rc_second_frame = translate_frameshifted(reverse_complement(sequence[1:]))
    rc_third_frame = translate_frameshifted(reverse_complement(sequence[2:]))
    
    translated_sequences = [first_frame,second_frame,third_frame,rc_first_frame,rc_second_frame,rc_third_frame]
    max_length_of_segments = []
    for translated_sequence in translated_sequences:
        length_of_translated_segments = [len(segment) for segment in translated_sequence.split("_")]
        max_length_of_segments.append(max(length_of_translated_segments))
        
    return max(max_length_of_segments)
    
    

def main():
    options = parseCommandLineArguments()
    
    os.system(f"mkdir -p {options.output_directory}")
    
    if options.logfilename == None:
        options.logfilename = f"{options.output_directory}/progress.log"
        
        
    configureLogger( options )    
    logging.info( "Logger has been configured" )
    
    ################################################################################################################################################################################################################################################
    # Pull down docker or singularity images
    ################################################################################################################################################################################################################################################
    
    access_key_raw = "ghp_fr6AvS8hayuREMOVETHISTEXTjmncOJqfLwgb0ueYXNk0hxnps"
    access_key = "".join(access_key_raw.split("REMOVETHISTEXT"))
    
    
    list_of_softwares_with_versions = {"samtools":"1.14",
                                       "trimmomatic":"0.39",
                                       "sratools":"3.0.0",
                                       "bowtie2":"0.7.17",
                                       "salmon":"1.8.0",
                                       "gffread":"0.12.1",
                                       "deseq2":"latest",
                                       "bowtie2":"2.4.5",
                                       "multiqc":"1.12",
                                       "star":"2.7.9a",
                                       "spades":"3.15.4",
                                       "cdhit":"4.8.1"}

    volumes_list = [f"{options.output_directory}:{options.output_directory}",
                    f"{options.temp_directory}:{options.temp_directory}",
                    f"{'/'.join(options.reference.split('/')[:-1])}:{'/'.join(options.reference.split('/')[:-1])}"
                    ]
    
    os.system( f"mkdir -p {options.output_directory}/singularity_images" )
    os.system( f"which docker > {options.output_directory}/find_docker 2> {options.output_directory}/find_docker" )
    os.system( f"which singularity > {options.output_directory}/find_singularity 2> {options.output_directory}/find_singularity" )
    docker_installed = 1 if "no docker in" not in open( f"{options.output_directory}/find_docker", "r" ).read() else 0
    singularity_installed = 1 if "no singularity in" not in open( f"{options.output_directory}/find_singularity", "r" ).read() else 0

    if docker_installed == 0 and singularity_installed == 0:
        print( "You need to have either docker or singularity installed" )
        sys.exit()

    framework_of_choice = ""
    if options.framework == "docker":
        if docker_installed == 1:
            framework_of_choice = "docker"
        else:
            framework_of_choice = "singularity"

    if options.framework == "singularity":
        if singularity_installed == 1:
            framework_of_choice = "singularity"
        else:
            framework_of_choice = "docker"
    
    print(framework_of_choice)
    if framework_of_choice == "docker":
        os.environ["CR_PAT"] = access_key
        os.system( f"echo $CR_PAT | docker login ghcr.io -u sagnikbanerjee15 --password-stdin" )
        for software in list_of_softwares_with_versions:
            version = list_of_softwares_with_versions[software]
            os.system( f"docker pull ghcr.io/sagnikbanerjee15/docker_tools_and_pipelines/{software}:{version}" )
    else:
        os.environ["CR_PAT"] = access_key
        os.system( f"echo $CR_PAT | singularity remote login -u sagnikbanerjee15 --password-stdin docker://ghcr.io" )
        for software in list_of_softwares_with_versions:
            version = list_of_softwares_with_versions[software]
            if os.path.exists(f"{options.output_directory}/singularity_images/{software}:{version}")==False:
                os.system( f"singularity pull {options.output_directory}/singularity_images/{software}:{version} docker://ghcr.io/sagnikbanerjee15/dockerized_tools_and_pipelines/{software}:{version}" )
    ################################################################################################################################################################################################################################################

    ################################################################################################################################################################################################################################################
    # Create directories and sub-directories for analysis
    ################################################################################################################################################################################################################################################
    options.star_index = f"{options.output_directory}/star_index"
    os.system(f"mkdir -p {options.star_index}")
    os.system(f"mkdir -p {options.temp_directory}/star_index")
    options.alignments = f"{options.output_directory}/alignments"
    os.system(f"mkdir -p {options.alignments}")
    os.system(f"mkdir -p {options.temp_directory}/alignments")
    options.denovo_assembly = f"{options.output_directory}/denovo_assembly"
    os.system(f"mkdir -p {options.denovo_assembly}")
    os.system(f"mkdir -p {options.temp_directory}/denovo_assembly")

    ################################################################################################################################################################################################################################################
    # Read data from metadata file
    ################################################################################################################################################################################################################################################
    
    #options.metadata = pd.read_csv(options.metadatafilename)
    # Restruture later
    fhr = open(options.metadatafilename, "r")
    options.metadata = []
    for line in fhr:
        if "SampleName" in line: continue
        options.metadata.append(line.strip().split(','))
    fhr.close()
    
    
    ################################################################################################################################################################################################################################################
    # Prepare genome indices
    ################################################################################################################################################################################################################################################
    
    # Generate the STAR index
    if os.path.exists(f"{options.output_directory}/star_index/genomeParameters.txt") == False and os.path.exists(f"{options.temp_directory}/star_index/genomeParameters.txt") == False:
        cmd = f"STAR --runMode genomeGenerate --runThreadN {options.cpu} --genomeFastaFiles {options.reference} --genomeDir {options.star_index}"
        cmd += f" 1> {options.star_index}.output"
        cmd += f" 2> {options.star_index}.error"
        
        software = "star"
        version = list_of_softwares_with_versions[software]
        runSingularityCommand(logging, 
                              "STAR", 
                              version, 
                              image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                              container_name = "star_index_prep", 
                              volumes = volumes_list,
                              command = cmd, 
                              cpus = options.cpu, 
                              memory = '100g')
        
        # Move the star index to the temp directory if a transfer is requested
        if (options.transfer):
            cmd = f"mv {options.star_index} {options.temp_directory}"
            os.system(cmd)
            
    
        
    # Copy the reference index if it is not present
    cmd = f"cp -r {options.temp_directory}/star_index {options.output_directory}"
    os.system(cmd)
    
    for row in options.metadata:
        samplename, ended, cultivar, condition, timepoint, biological_replicate, location = row
        ################################################################################################################################################################################################################################################
        # Align short reads to reference
        ################################################################################################################################################################################################################################################
        if os.path.exists(f"{options.output_directory}/alignments/{samplename}_Aligned.sortedByCoord.out.bam") == False and os.path.exists(f"{options.temp_directory}/alignments/{samplename}_Aligned.sortedByCoord.out.bam") == False:
            # Copy the raw data from the directory
            if ended == "SE":
                cmd = f"cp {location}/{samplename}.fastq.gz {options.output_directory}/alignments"
                os.system(cmd)
            else:
                cmd = f"cp {location}/{samplename}_1.fastq.gz {options.output_directory}/alignments"
                os.system(cmd)
                cmd = f"cp {location}/{samplename}_2.fastq.gz {options.output_directory}/alignments"
                os.system(cmd)
            
            cmd = f"STAR "
            cmd += f" --genomeDir {options.star_index}"
            cmd += f" --outSAMtype BAM SortedByCoordinate "
            cmd += f" --outFilterMultimapNmax 100 "  
            cmd += f" --alignIntronMin 20  "
            cmd += f" --alignIntronMax 10000 "
            cmd += f" --limitBAMsortRAM 107374182400 "
            cmd += f" --alignEndsType Local " # ALLOWS soft clipping 
            cmd += f" --outSAMprimaryFlag AllBestScore "
            cmd += f" --outFilterScoreMinOverLread 0.60"
            cmd += f" --outFilterMatchNminOverLread 0.60 "
            cmd += f" --outSAMattributes NH HI AS nM NM MD jM jI XS "
            cmd += f" --outReadsUnmapped Fastx "
            cmd += f" --outFileNamePrefix {options.output_directory}/alignments/{samplename}_"
            cmd += f" --readFilesCommand zcat "
            cmd += f" --readFilesIn {options.output_directory}/alignments/{samplename}_1.fastq.gz {options.output_directory}/alignments/{samplename}_2.fastq.gz "
            cmd += f" 1> {options.output_directory}/alignments/{samplename}.output "
            cmd += f" 2> {options.output_directory}/alignments/{samplename}.error "
            
            software = "star"
            version = list_of_softwares_with_versions[software]
            runSingularityCommand(logging, 
                                  "STAR", 
                                  version, 
                                  image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                                  container_name = "star_alignment",
                                  volumes = volumes_list,
                                  command = cmd, 
                                  cpus = options.cpu, 
                                  memory = '100g')
            if options.transfer:
                cmd = f"mv {options.output_directory}/alignments/{samplename}*.bam {options.temp_directory}/alignments/"
                os.system(cmd)
                
                cmd = f"mv {options.output_directory}/alignments/{samplename}*.out {options.temp_directory}/alignments/"
                os.system(cmd)
                
                cmd = f"rm {options.output_directory}/alignments/{samplename}*gz"
                os.system(cmd)
    
    # de novo align the unmapped reads
    for row in options.metadata:
        samplename, ended, cultivar, condition, timepoint, biological_replicate, location = row
        ################################################################################################################################################################################################################################################
        # Move unmapped reads to working folder
        ################################################################################################################################################################################################################################################
        if os.path.exists(f"{options.denovo_assembly}/{samplename}_101") == False and os.path.exists(f"{options.temp_directory}/denovo_assembly/{samplename}_101") == False:
            cmd = f"cp {options.temp_directory}/alignments/{samplename}_Unmapped* {options.output_directory}/alignments"
            os.system(cmd)
            if ended == "SE":
                cmd = f"mv {options.output_directory}/alignments/{samplename}_Unmapped.out.mate {options.output_directory}/alignments/{samplename}_Unmapped.out.mate.fq"
                os.system(cmd)
            else:
                cmd = f"mv {options.output_directory}/alignments/{samplename}_Unmapped.out.mate1 {options.output_directory}/alignments/{samplename}_Unmapped.out.mate1.fq"
                os.system(cmd)
                
                cmd = f"mv {options.output_directory}/alignments/{samplename}_Unmapped.out.mate2 {options.output_directory}/alignments/{samplename}_Unmapped.out.mate2.fq"
                os.system(cmd)
            
        cmd  = f"spades.py "
        cmd += f" --rna "
        if ended == "SE":
            cmd += f" -s {options.output_directory}/alignments/{samplename}_Unmapped.out.mate.fq "
        else:
            cmd += f" -1 {options.output_directory}/alignments/{samplename}_Unmapped.out.mate1.fq "
            cmd += f" -2 {options.output_directory}/alignments/{samplename}_Unmapped.out.mate2.fq "
        cmd += f" --threads {options.cpu}"
        cmd += f" -k 101 "
        cmd += f" -o {options.denovo_assembly}/{samplename}_101 "
        cmd += f" 1> {options.denovo_assembly}/{samplename}_101.output "
        cmd += f" 2> {options.denovo_assembly}/{samplename}_101.error "
        
        if os.path.exists(f"{options.denovo_assembly}/{samplename}_101/transcripts.fasta") == False and os.path.exists(f"{options.temp_directory}/denovo_assembly/{samplename}_101/transcripts.fasta") == False:
            software = "spades"
            version = list_of_softwares_with_versions[software]
            runSingularityCommand(logging, 
                                      "spades", 
                                      version, 
                                      image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                                      container_name = "spades_assembly",
                                      volumes = volumes_list,
                                      command = cmd, 
                                      cpus = options.cpu, 
                                      memory = '300g')
        
        cmd = f"rm {options.output_directory}/alignments/{samplename}_Unmapped* "
        os.system(cmd)
        
        if options.transfer:
            cmd = f"mv {options.output_directory}/denovo_assembly/{samplename}_101* {options.temp_directory}/denovo_assembly"
            os.system(cmd)
    
    # Generate a single transcriptome from unmapped reads
    all_sequences = {}
    for row in options.metadata:
        samplename, ended, cultivar, condition, timepoint, biological_replicate, location = row
        ################################################################################################################################################################################################################################################
        # Copy assembled "transcripts" to working folder
        ################################################################################################################################################################################################################################################
        cmd = f"mkdir -p {options.denovo_assembly}/{samplename}_101"
        os.system(cmd)
        cmd = f"cp {options.temp_directory}/denovo_assembly/{samplename}_101/transcripts.fasta {options.denovo_assembly}/{samplename}_101/"
        os.system(cmd)
        
        denovo_assembled_sequences = readMultiLineFastaFile(f"{options.denovo_assembly}/{samplename}_101/transcripts.fasta")
        
        # Remove sequences that have less than 100 aa
        sequence_ids_to_be_removed = []
        for sequence_id in denovo_assembled_sequences: 
            if lengthOfLongestORF(denovo_assembled_sequences[sequence_id]) < 100:
                sequence_ids_to_be_removed.append(sequence_id)
        
        for sequence_id in sequence_ids_to_be_removed:
            del denovo_assembled_sequences[sequence_id]
            
        for sequence_id in denovo_assembled_sequences:
            all_sequences[f"{sequence_id}_{cultivar}_{condition}_{timepoint}_{biological_replicate}"] = denovo_assembled_sequences[sequence_id]
            
    merged_filename = f"{options.denovo_assembly}/merged_transcripts.fasta"
    if os.path.exists(merged_filename) == False:
        fhw = open(merged_filename,"w")
        for sequence_id in all_sequences:
            fhw.write(f">{sequence_id}\n{all_sequences[sequence_id]}\n")
        fhw.close()
    
    # Generate CDHIT clusters
    cluster_similarity = 0.90
    cmd  = f"cd-hit-est "
    cmd += f" -i {options.denovo_assembly}/merged_transcripts.fasta "
    cmd += f" -o {options.denovo_assembly}/merged_transcripts_cdhit_clusters_{cluster_similarity} "
    cmd += f" -c {cluster_similarity} "
    cmd += f" -T {options.cpu} "
    cmd += f" -d 0 "
    cmd += f" -M 5000 "
    cmd += f" 1> {options.denovo_assembly}/merged_transcripts_cdhit_clusters_{cluster_similarity}.output "
    cmd += f" 2> {options.denovo_assembly}/merged_transcripts_cdhit_clusters_{cluster_similarity}.error "
    
    if os.path.exists(f"{options.denovo_assembly}/merged_transcripts_cdhit_clusters_0.90.clstr") == False:
        software = "cdhit"
        version = list_of_softwares_with_versions[software]
        runSingularityCommand(logging, 
                              "CDHIT", 
                              version, 
                              image_location = f"{options.output_directory}/singularity_images/{software}:{version}", 
                              container_name = "star_alignment",
                              volumes = volumes_list,
                              command = cmd, 
                              cpus = options.cpu, 
                              memory = '100g')   
    
    
    
if __name__ == "__main__":
    main()
    
    
    
    
    